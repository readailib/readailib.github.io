<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShenH.&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/543fc8a83d9b480e5f69c3842db96518</icon>
  <subtitle>Learn Anything, Anytime, Anywhere~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://readailib.com/"/>
  <updated>2019-03-05T16:48:38.587Z</updated>
  <id>https://readailib.com/</id>
  
  <author>
    <name>ShenHengheng</name>
    <email>shenhengheng17g@ict.ac.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在树莓派kubernetes集群部署gRPC框架编写的微服务</title>
    <link href="https://readailib.com/2019/03/06/kubernetes/raspberrypi/deploy-a-microservice-on-k8s/"/>
    <id>https://readailib.com/2019/03/06/kubernetes/raspberrypi/deploy-a-microservice-on-k8s/</id>
    <published>2019-03-05T16:14:16.000Z</published>
    <updated>2019-03-05T16:48:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>今天带着大家如何在树莓派kubernetes集群中部署微服务,这次文章和上次文章的区别就是这个涉及两个微服务,如何使两个微服务在kubernetes中实现服务之间的调用可能是与上次的不同之处,这次也使用Google的开源框架gRPC框架来加快微服务的开发.</p><a id="more"></a><p>本次教程需要准备:</p><ul><li>一个启动好的树莓派kubernetes集群(参考: <a href="https://41sh.cn/?id=16" target="_blank" rel="noopener">边缘智能-在树莓派上部署kubernetes集群</a>)</li><li>protobuf工具(参考 <a href="https://github.com/google/protobuf,从release页下载对应的操作系统的版本即可" target="_blank" rel="noopener">https://github.com/google/protobuf,从release页下载对应的操作系统的版本即可</a>)</li><li>Docker (参考: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a>)</li><li>kubectl工具 (参考: <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a>)<br>本次文章主要参考: </li><li><a href="https://outcrawl.com/getting-started-microservices-go-grpc-kubernetes" target="_blank" rel="noopener">Getting Started with Microservices using Go, gRPC and Kubernetes</a><br>代码:</li><li><a href="https://github.com/rh01/grpc-microservice-k8s" target="_blank" rel="noopener">https://github.com/rh01/grpc-microservice-k8s</a></li></ul><h2 id="定义我们的protobuf文件"><a href="#定义我们的protobuf文件" class="headerlink" title="定义我们的protobuf文件"></a>定义我们的protobuf文件</h2><p>protobuf是google的一个序列化结构化数据工具,它可以让人们定义好相关的结构,使用protoc工具自动生成对应的代码.类似的结构化工具还有thrift.</p><blockquote><p>微服务:这里我主要实现一个最大公约数的功能,输入两个数值,返回这两个数的最大公约数.</p></blockquote><p>这里既然使用gRPC来做,那么主要使用rpc来实现服务调用,因为rpc实现的是服务之间的同步调用，即客户端调用服务并等待响应。gRPC是提供RPC功能的框架之一。此时我们需要使用Protocol Buffer的接口定义语言中编写消息类型和服务的代码并进行编译。</p><p>下面就是我们使用protobuf语言定义的消息类型和服务.(具体参考: <a href="https://grpc.io/docs/quickstart/go.html)" target="_blank" rel="noopener">https://grpc.io/docs/quickstart/go.html)</a></p><pre><code class="bash">$ mkdir -pv ~/go/src/github.com/rh01/mini-deploy-app/pb$ cd ~/go/src/github.com/rh01/mini-deploy-app/pb$ vim pb.proto</code></pre><pre><code class="yaml">syntax = &quot;proto3&quot;; // protobuf 版本package pb;        // 代码生成的package名字// 定义的请求消息体message GCDRequest {    uint64 a = 1;    uint64 b = 2;}// 定义的响应消息体message GCDResponse {    uint64 result = 1;}// 调用的远程服务,这是client请求server端的远程计算服务service GCDService {    rpc Compute (GCDRequest) returns (GCDResponse) {}}</code></pre><p>接下来我们需要使用 protoc 生成对应的服务代码</p><pre><code>$ protoc -I . --go_out=plugins=grpc:. ./*.proto</code></pre><blockquote class="colorquote warning"><blockquote><p>提前须知:</p><ol><li>执行上面的指令需要使用安装 grpc 和 proto-gen-go 工具,使用下面的命令:</li></ol><pre><code class="bash">$ go get -u google.golang.org/grpc$ go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><ol start="2"><li>将 $GOPATH/bin 目录添加到PATH环境变量中</li></ol><pre><code class="bash">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</code></pre></blockquote></blockquote><p>这时应该生成了 gcd.pb.go 程序.</p><h2 id="最大公约数服务"><a href="#最大公约数服务" class="headerlink" title="最大公约数服务"></a>最大公约数服务</h2><h3 id="定义服务端"><a href="#定义服务端" class="headerlink" title="定义服务端"></a>定义服务端</h3><p>gcd 服务将会使用上一步生成的代码进行实现gcd计算服务.</p><pre><code class="bash">$ cd ~/go/src/github.com/rh01/mini-deploy-app/$ mkdir -p gcd$ vim main.go</code></pre><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;net&quot;    context &quot;golang.org/x/net/context&quot;    pb &quot;github.com/rh01/mini-deploy-app/pb&quot;    &quot;google.golang.org/grpc&quot;    &quot;google.golang.org/grpc/reflection&quot;)</code></pre><p>在main函数中主要定义server结构,并将其注册为server端,用于处理 gcd 计算的请求.然后启动grpc服务.</p><pre><code class="go">type server struct {}func main() {    lis, err := net.Listen(&quot;tcp&quot;, &quot;:3000&quot;)    if err != nil {        log.Fatalf(&quot;Failed to listen: %v&quot;, err)    }    s := grpc.NewServer()    pb.RegisterGCDServiceServer(s, &amp;server{})    reflection.Register(s)    if err := s.Serve(lis); err != nil {        log.Fatalf(&quot;Failed to serve: %v&quot;, err)    }}</code></pre><p>实现GCDServiceServer接口的 <code>Compute</code> 方法, server 结构对象的指针作为方法接受者.</p><pre><code class="Go">// gcd.pb.go// GCDServiceServer is the server API for GCDService service.type GCDServiceServer interface {    Compute(context.Context, *GCDRequest) (*GCDResponse, error)}func (s *server) Compute(ctx context.Context, r *pb.GCDRequest) (*pb.GCDResponse, error) {    a, b := r.A, r.B    for b != 0 {        a, b = b, a%b    }    return &amp;pb.GCDResponse{Result: a}, nil}</code></pre><h2 id="定义RESTFul客户端"><a href="#定义RESTFul客户端" class="headerlink" title="定义RESTFul客户端"></a>定义RESTFul客户端</h2><p>前端使用 <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a> 框架,主要是提供一个REST风格的访问方式和调用我们定义的gcd服务端执行实际的计算任务.</p><pre><code class="go">$ cd ~/go/src/github.com/rh01/mini-deploy-app/$ mkdir -p api$ vim main.go</code></pre><pre><code>package mainimport (    fmt &quot;fmt&quot;    &quot;log&quot;    &quot;net/http&quot;    &quot;strconv&quot;    &quot;github.com/gin-gonic/gin&quot;    pb &quot;github.com/rh01/mini-deploy-app/pb&quot;    &quot;google.golang.org/grpc&quot;)func main() {    conn, err := grpc.Dial(&quot;gcd-service:3000&quot;, grpc.WithInsecure())    if err != nil {        log.Fatalf(&quot;Dial failed: %v&quot;, err)    }    gcdClient := pb.NewGCDServiceClient(conn)}</code></pre><p>上面的代码主要使用rpc的方式访问我们定义的服务端,此时的 gcd-service:3000 就是我们gcd服务端的 endpoint,这个就是服务地址,需要在kubernetes中定义.</p><pre><code class="go">    r := gin.Default()    r.GET(&quot;/gcd/:a/:b&quot;, func(c *gin.Context) {        // Parse parameters        a, err := strconv.ParseUint(c.Param(&quot;a&quot;), 10, 64)        if err != nil {            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;Invalid parameter A&quot;})            return        }        b, err := strconv.ParseUint(c.Param(&quot;b&quot;), 10, 64)        if err != nil {            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;Invalid parameter B&quot;})            return        }        // Call GCD service        req := &amp;pb.GCDRequest{A: a, B: b}        if res, err := gcdClient.Compute(c, req); err == nil {            c.JSON(http.StatusOK, gin.H{                &quot;result&quot;: fmt.Sprint(res.Result),            })        } else {            c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: err.Error()})        }    })</code></pre><p>接下来处理 /gcd/:a/:b 请求,读取参数 A 和 B,然后调用GCD服务.</p><p>最后运行我们的REST API端.启动一个API server.</p><pre><code class="go">    // Run HTTP server    if err := r.Run(&quot;:3000&quot;); err != nil {        log.Fatalf(&quot;Failed to run server: %v&quot;, err)    }</code></pre><h2 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建Docker镜像</h2><p>下面是我定义的Dockerfile文件,因为有两个服务,所以这里分成两个Docker镜像,一个是gcd服务,另外一个是提供RESTAPI访问的客户端api.</p><blockquote><p>有关Docker的多阶段构建参考: <a href="https://www.41sh.cn/?id=61" target="_blank" rel="noopener">[实战] 将golang编写的微服务部署在树莓派搭建的kubernetes集群</a></p></blockquote><pre><code class="dockerfile"># Dockerfile.gcdFROM golang AS build-envWORKDIR /go/src/github.com/rh01/mini-deploy-app/gcdCOPY gcd .COPY pb ../pbCOPY vendor ../vendorENV http_proxy http://192.168.1.9:12333ENV https_proxy http://192.168.1.9:12333RUN go get -u -v github.com/kardianos/govendorRUN govendor syncRUN GOOS=linux GOARCH=arm GOARM=7 go build -v -o /go/src/github.com/rh01/mini-deploy-app/gcd-serverFROM armhf/alpine:latestCOPY --from=build-env /go/src/github.com/rh01/mini-deploy-app/gcd-server /usr/local/bin/gcdEXPOSE 3000CMD [ &quot;gcd&quot; ]</code></pre><pre><code class="dockerfile"># Dockerfile.apiFROM golang AS build-envWORKDIR /go/src/github.com/rh01/mini-deploy-app/apiCOPY api .COPY pb ../pbCOPY vendor ../vendorENV http_proxy http://192.168.1.9:12333ENV https_proxy http://192.168.1.9:12333RUN go get -u -v github.com/kardianos/govendorRUN govendor syncRUN GOOS=linux GOARCH=arm GOARM=7 go build -v -o /go/src/github.com/rh01/mini-deploy-app/api-serverFROM armhf/alpine:latestCOPY --from=build-env /go/src/github.com/rh01/mini-deploy-app/api-server /usr/local/bin/apiEXPOSE 3000CMD [ &quot;api&quot; ]</code></pre><p>然后构建</p><pre><code class="bash">$ docker build -t rh02/apiserver:v1.0.0 -f Dockerfile.api . $ docker build -t rh02/gcdserver:v1.0.0 -f Dockerfile.gcd .</code></pre><h2 id="部署到kubernetes"><a href="#部署到kubernetes" class="headerlink" title="部署到kubernetes"></a>部署到kubernetes</h2><p>定义两个Deployment和对应的两个Service,并且将gcd服务的名字写成我们api服务调用的名字:gcd-service.</p><p>下面是gcd的deployment和service的定义: gcd.yaml</p><pre><code class="yaml">apiVersion: apps/v1beta1kind: Deploymentmetadata:  name: gcd-deployment  labels:    app: gcdspec:  selector:    matchLabels:      app: gcd  replicas: 3  template:    metadata:      labels:        app: gcd    spec:      containers:      - name: gcd        image: rh02/gcdserver:v1.0.0        imagePullPolicy: Always      ports:      - name: gcd-service        containerPort: 3000---apiVersion: v1kind: Servicemetadata:  name: gcd-servicespec:  selector:    app: gcd  ports:  - port: 3000    targetPort: gcd-service</code></pre><p>创建api.yaml, service类型设置为NodePort,从而可以在集群外部也可以访问,对于GCD服务,类型设置为ClusterIP即可,只需要在集群内部访问就可以.</p><pre><code class="yaml">apiVersion: apps/v1beta1kind: Deploymentmetadata:  name: api-deployment  labels:    app: apispec:  selector:    matchLabels:      app: api  replicas: 1  template:    metadata:      labels:        app: api    spec:      containers:      - name: api        image: rh02/apiserver:v1.0.0        imagePullPolicy: Always      ports:      - name: api-service        containerPort: 3000---apiVersion: v1kind: Servicemetadata:  name: api-servicespec:  type: NodePort  selector:    app: api  ports:  - port: 3000    targetPort: api-service</code></pre><p>使用kubectl创建两个资源:</p><pre><code class="bash">$ kubectl create -f api.yaml$ kubectl create -f gcd.yaml</code></pre><p>检查所有的Pod是否正在运行, 可以指定 <code>-w</code> 标记,查看启动的过程.</p><pre><code class="bash">$ kubectl get pods -wNAME                             READY     STATUS    RESTARTS   AGEapi-deployment-778049682-3vd0z   1/1       Running   0          3sgcd-deployment-544390878-0zgc8   1/1       Running   0          2sgcd-deployment-544390878-p78g0   1/1       Running   0          2sgcd-deployment-544390878-r26nx   1/1       Running   0          2s</code></pre><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p><img src="https://www.41sh.cn/zb_users/upload/2019/03/201903051551771763579640.png" alt="截图_2019-03-05_15-42-18.png"></p><p><img src="https://www.41sh.cn/zb_users/upload/2019/03/201903051551771802295607.png" alt="截图_2019-03-05_15-43-02.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天带着大家如何在树莓派kubernetes集群中部署微服务,这次文章和上次文章的区别就是这个涉及两个微服务,如何使两个微服务在kubernetes中实现服务之间的调用可能是与上次的不同之处,这次也使用Google的开源框架gRPC框架来加快微服务的开发.&lt;/p&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://readailib.com/tags/kubernetes/"/>
    
      <category term="RaspberryPi" scheme="https://readailib.com/tags/RaspberryPi/"/>
    
      <category term="Edge computing" scheme="https://readailib.com/tags/Edge-computing/"/>
    
      <category term="gRPC" scheme="https://readailib.com/tags/gRPC/"/>
    
      <category term="Golang" scheme="https://readailib.com/tags/Golang/"/>
    
  </entry>
  
</feed>
